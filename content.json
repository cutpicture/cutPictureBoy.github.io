{"pages":[],"posts":[{"title":"HTTPS简介","text":"HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为相比如HTTP，HTTPS多了层SSL，用户对数据的加密，目前使用HTTP2必须开启HTTPS 由于HTTP/1.x 中，数据在互联网中以明文的方式传输，很容易被中间人拦截获取，甚至进行篡改通信内容。为了防止上述现象的发生，人们采用对传输信息进行加密处理。 准备阶段服务器生成非对称加密使用的公钥和私钥，并将公钥上传给证书的发布机构CA，来获取封装了的CA证书。CA证书包括以下内容： 证书的发布机构CA 证书的有效期 公钥 证书所有者 签名(对关键数据进行使用HASH，再用CA机构的私钥进行加密) 等等 注：对数据进行HASH处理得到HASH1，再对HASH1使用CA证书私钥加密，客户端再使用操作系统中的CA公钥对HASH1进行解密，再对关键数据进行HASH处理得到HASH2，让HASH1与HASH2进行比对，确保数据来自于证书的所有者且数据未被篡改。 第一步 客户端发起请求客户端首先向服务器发起请求，客户端主要向服务器提供一下信息： 支持的协议版本 客户端生成的随机数A 支持的加密算法 支持的压缩算法 第二步 服务器响应 确认使用的加密通信协议版本 服务器生成的随机数B 确认使用的加密算法 服务器证书 第三步 客户端响应客户端首先校验证书的正确性，保证证书来源于可信的CA机构颁发，证书域名于实际域名一致，且证书未过期和未被中间人篡改(检查签名)。如无问题，客户端取出证书中的公钥，向服务器发送以下信息 方案一：客户端生成的随机数C，并使用服务器证书里公钥加密此随机数C(使用RSA交换密钥) 方案二：服务端使用DH对随机数M加密生成KM发给客户端，客户端再使用DH对随机数N产生KN发给服务端(DH 算法交换密钥) 编码改变通知：表示以后的信息将要商定的加密方法和密钥加密发送 握手结束通知 第四步 生成session key 方案一：根据随机数A、B、C 生成密钥session key 方案二：使用KM 和 N 于 KN 和 M 利用DH算法算出的数P，并利用P和A、B生成session key。 利用session key进行对称加密，进行数据传输","link":"/2019/03/18/HTTPS简介/"},{"title":"HTTP/2简介","text":"参考:HTTP/2 简介 二进制分帧HTTP2 中，同域名下所有的数据通信都在单个TCP连接上完成，该连接可以承载任意数量的双向数据流，每个数据流都以消息的形式发送，而消息由一个或多个帧组成，同时多个帧可以乱序发送，根据帧首部的流标识进行重新组装。 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。 消息：与逻辑请求或响应消息对应的完整的一系列帧。 帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。 这些概念的关系总结如下： 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 多路复用而HTTP/1.x中，每个连接每次只能处理一个请求 - 响应，客户端一般创建多个TCP连接来进行并发请求，同时为了控制资源的消耗，同域名下的并发数并不会很高(一般为6 - 8个)，因为资源需要进行排队而导致阻塞。有了二进制分帧后，所有同域名的通信都通过单个TCP连接完成，因此所有的HTTP/2连接都是永久了。减少了创建多个TCP连接的系统资源消耗，并且资源不再需要排队，提高了资源的加载速度。 数据流优先级HTTP/2中，每个数据流都会被分配一个介于1 - 256之间的整数，作为数据流的优先级，数字越低代表优先级越高。服务器通过优先级来调度系统资源，确保高优先级的响应以最优的方式传输至客户端。 服务器推送HTTP/2打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流。服务器可以根据一个请求推送多个资源，而不必再等待客户端解析了该单个资源的的响应信息后由再向服务器发起更多请求。所有服务器推送数据流都有PUSH_PROMISE帧发起，表明服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输(以免资源创建的重复请求)。客户端收到PUSH_PROMISE帧后，根据自身情况选择拒绝数据流RST_STREAM帧。 头部压缩在HTTP/1.x中，每个HTTP请求都承载一组请求头。而通常多个HTTP请求的头信息都是大致相同了，这样造成了网络资源的浪费，有时增加的资源达到上千字节(例如cookie信息)。因此，HTTP2使用HPACK来对请求头和响应头信息。","link":"/2019/03/18/HTTP2简介/"},{"title":"Vue服务端渲染初探","text":"本文基于Vue-cli3 初始化出来的项目进行改造，参考https://ssr.vuejs.org/zh/ 实现 什么是服务端渲染在SPA(单页应用)中，一般由Javascript动态生成HTML插入到页面中，而服务端渲染则改为由服务器根据请求生成好HTML，再将这部分返回给浏览器。即将原来部分由前端生成的HTML改为后端生成。 服务端渲染优势通常情况下，SPA都是在页面加载完成后，由Javascript动态生成HTML再插入到页面中，而不是重新加载整个新页面。这样的优点是避免页面切换而打断用户，但也带来了SEO(搜索引擎优化)和首页白屏的性能问题。而使用SSR的优势在于可以优化上述的问题，让内容更容易被搜索引擎爬取和减少内容到达时间。 服务端渲染缺点SSR需要对原始项目进行部分重构，并且需要更多的服务器资源去计算，因此开发和运营成本会更高。 ###对于Vue而言，beforeCreate和created这两个生命周期的代码将在SSR的过程中调用，而其他生命周期钩子函数都只会在客户端执行。同时需要避免在beforeCreate和created中产生全局副作用代码，以免产生内存泄漏。","link":"/2019/03/28/Vue服务端渲染初探/"},{"title":"读《重构-改善既有代码的设计》","text":"什么是重构重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。重构（动词）：使用一系列的重构手法，在不改变软件可观察行为的前提下，调整其结构。 在行业中，很多人使用‘重构’来指代任何形式的代码清洁，但上面的定义所指的是一种特定的清理代码的方式。重构的关键在于运用大量微小切保护软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组成。因此再重构的过程中，代码很少进入不可工作的状态，即便重构没有完成，也可以再任何时候停下来。 两顶帽子比喻使用重构技术开发软件时，Kent Beck通常把自己的时间分配给两种截然不同的两种行为：添加新功能和重构，不在开发的过程中断变换这两顶帽子。添加新功能时，不应该修改既有的代码，而是只管添加新的功能，并让软件通过测试正常运行。重构时，不再添加新的功能，只调整代码结构，只在必要的时候才修改测试。 为什么要重构重构不是所谓的‘银弹’，但它可以帮助你始终良好的控制代码。 重构改进软件的设计如果没有重构，程序的内部设计就会逐渐变得腐烂变质，当人们只为短期目的修改代码时，他们通常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应，越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。而经常性的重构有助于维护代码该有的形态。 重构使软件更容易理解代码除了跑在机器上，更要给自己和其他人去读，我们需要改变开发节奏，让代码更容易被理解。重构可以帮助我们让代码更加的易读，让结构不好的代码更好的表达自己的意图。 重构帮助找到bug对代码进行重构的同时，更加深入的理解代码的所作所为，并将新的理解表现在代码中，同时也将以前想不到的bug揪了出来。 重构提高编程速度当我们开始一个新的项目时，一开始的进展往往很快，但越到后面，我们需要花费越来越多的时间去将新的功能添加到现有的代码中，而不断出现的bug修复起来也越来越慢。到最后代码库就像补丁摞补丁，开发者需要更细致的工作才能弄清楚项目的结构。拖慢新功能开发的进度，到左后只能不得不重写。 什么时候重构 预备性重构：让添加新功能更容易","link":"/2020/07/18/读《重构-改善既有代码的设计》/"},{"title":"HTTP缓存机制","text":"参考缓存详解HTTP缓存 什么是缓存？ 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。 为什么需要缓存使用缓存拥有一下优势： 缓解服务器压力，客户端不需要每次去请求资源； 提升性能，由于资源存在于本地，不需要从服务器获取，因此速度更快； 服务器带宽消耗减少； 因此可以得出，使用缓存可以节约服务器的资源同时让网站的性能更加优秀。但是因为并不是所有资源都是永久不变的，重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。因此，缓存需要合理配置。 缓存的分类缓存可以分为两类：私有缓存和共享缓存 私有缓存（浏览器缓存）私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。 共享缓存（代理缓存）共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。由于所有的请求都会首先通过代理服务器，因此代理服务器可以对热门的资源进行缓存，其他用户访问热门资源的时候，就可以使用代理缓存的资源而不必从服务器获取，这样热门的资源就会被重复使用，减少网络拥堵与延迟。 缓存资源类型常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。 不变的重定向: 响应状态码：301。 错误响应: 响应状态码：404 的一个页面。 不完全的响应: 响应状态码 206，只返回局部的信息。 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应。 缓存机制浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。因此，对于缓存的控制主要是通过配置资源的响应头。 缓存机制可以分为强缓存和协商缓存两个阶段。是首先进行强缓存的判断，然后进行协商缓存的判断，可以通过下面这样图来理解整个缓存机制。 强缓存首先进入强缓存的判定阶段，当向服务器请求一个资源的，若符合浏览器缓存资源的类型，则首先判断本地的缓存里面时候存在该资源。如果该资源不存在，则直接向服务器请求该资源，若该资源存在，进入下一步：判断该资源是否过期。若该资源未过期，则从缓存中读取该资源，若缓存已过期，则进入协商缓存的判定阶段。 强缓存命中时，Firefox浏览器表现为一个灰色的200状态码，Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。 关于缓存是从磁盘中获取还是从内存中获取，通过参考缓存详解：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 协商缓存当该资源文件已过期后，首先根据第一次资源请求的响应头中的ETAG和Last-Modified来判断客户端带上哪些字段去向服务器验证内容是否修改。 ETag 响应头作为缓存的一种强校验器，可以理解为该资源的版本号，是一个对用户代理(User Agent, 下面简称UA)不透明的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。 Last-Modified 响应头可以作为一种弱校验器，表示资源上一次修改的时间。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。 当向服务端发起缓存校验的请求时，服务端会返回 200 ok并在body里附上最新的资源表示返回正常的结果，客户端使用最新的资源并重新缓存该资源，或者服务端返回 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。 启发式缓存阶段另外存在的一个比较让人忽视，但实际上存在的缓存阶段为启发式缓存阶段，这个阶段表现为资源的响应头信息里不包含资源过期的信息，浏览器此时会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。所以当浏览器判断该资源的缓存的日期和当前时间的差是否大于该缓存时间周期，以此来判断资源是否过期。当感觉资源的缓存不受控制时，可以查找这方面的原因。 缓存相关HTTP首部字段字段列表 通用首部字段 字段名称 说明 Cache-Control 控制缓存具体的行为 Pragma HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存 Date 创建报文的日期时间(启发式缓存阶段会用到这个字段) 响应首部字段 字段名称 说明 ETag 服务器生成资源的唯一标识 Vary 代理服务器缓存的管理信息 Age 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小) 实体首部字段 字段名称 说明 Expires 告知客户端资源缓存失效的绝对时间 Last-Modified 资源最后一次修改的时间 字段详解1.Cache-Control通过cache-control的指令可以控制告诉客户端或是服务器如何处理缓存。这也是11个字段中指令最多的一个，我们先来看看请求指令： 指令 参数 说明 no-cache 无 强制源服务器再次验证 no-store 无 不缓存请求或是响应的任何内容 max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值 min-fresh=[秒] 必需 期望在指定时间内响应仍然有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取 cache-extension - 新的指令标记(token) 响应指令 指令 参数 说明 public 无 任意一方都能缓存该资源(客户端、代理服务器等) private 可省略 只能特定用户缓存该资源 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值 s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记(token) 另外，部分指令可以组合使用，比如Cache-Control: max-age=100, must-revalidate, public 上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。 2.Pragma 头Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。 Pragma: no-cache 服务端响应添加Pragma: no-cache，浏览器表现行为和强制刷新类似。 3.ExpiresExpires 同样是HTTP/1.0标准中定义的一个header属性，表示为缓存到期的绝对时间。我们也可以在html文件里直接使用:&lt;meta http-equiv=\"expires\" content=\"Thu, 30 Nov 2017 11:17:26 GMT\"&gt; 如何设置的时间已经过去，则会判断资源过期，向服务器发起请求。另外，当Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。 4.Last-Midified主要表示为该资源的修改时间，在响应头里返回给客户端，在协商缓存和启发式缓存中发挥作用。 Last-Modified有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了ETag这个字段。 5.If-Modified-Since当进入缓存协商阶段的时候，客户端会将第一次响应头的Last-Midified值存储到If-Modified-Since来发送给服务器验证资源是否修改过。若已修改，服务器返回200并在响应body里加上资源文件，若未修改则返回304告诉客户端仍然使用缓存资源并刷新缓存资源的过期时间。 6.If-Unmodified-Since这个字段字面意思和If-Modified-Since相反，但处理方式并不是相反的。如果文件在两次访问期间没有被修改则返回200和资源，如果文件修改了则返回状态码412(预处理错误)，一般用于断点下载时判断文件是否修改。 7.ETAG服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)，然后在浏览器第一次请求某一个URL时把这个标识放到响应头传到客户端。服务器端的返回状态会是200。ETag的值有可能包含一个 W/ 前缀，来提示应该采用弱比较算法。ETag: abc-123456ETag: W/abc-123456 8.If-None-MatchIf-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高。当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。If-None-Match: abc-123456 Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。如果没有资源的ETag值相匹配，那么返回304状态码。 9.If-Match作用与 If-Unmodified-Since 类似，同时无法使用弱ETAG值。 服务端缓存控制当Expires和Cache-Control:max-age=xxx同时存在的时候取决于缓存服务器应用的HTTP版本。应用HTTP/1.1版本的服务器会优先处理max-age，忽略Expires，而应用HTTP/1.0版本的缓存服务器则会优先处理Expires而忽略max-age。接下来看下和缓存服务器相关的两个字段。 用户行为对缓存的影响 操作 说明 打开新窗口 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器。 在地址栏回车 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 按后退按扭 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问。 按刷新按扭 无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）。 按强制刷新按钮 当做首次进入重新请求(返回状态码200)。","link":"/2018/05/20/HTTP缓存机制/"},{"title":"Severless初探","text":"一、什么是 Severless按照英文的字面意思进行直译的话，Severless的中文翻译为“无服务器”，听起来很神秘，让人一时无法理解其内涵。实际上它是一种全新的架构方式，人们一般称Severless为“无服务器架构”。Severless不是具体的一个编程框架、类库或者工具而是一种软件架构思想和方法，核心思想是用户无需关注支撑应用服务运行的底层主机。 所谓“无服务器”，并不是说Severless架构的软件应用不需要服务器就可以运行，其指的是用户无需关心软件应用运行涉及的底层服务器的状态、资源（CPU、内存、磁盘、网络）及数量。软件应用正常运行所需要的计算资源由底层的云计算平台提供。**在传统的场景中，当用户完成了应用开发后，软件将被部署到指定的运行环境。这个运行环境一般以服务器的方式体现，可能是物理主机，也可能是虚拟主机。根据业务场景的需要，用户申请一定数量、一定规格的服务器以满足该应用的正常运行。当应用上线以后，根据实际运营情况，用户可能申请更多的服务器资源进行扩容，以应对更高的访问量。此时用户需要关心每台服务器资源是否充足，需要关心服务器的状态，同时每台服务器上部署应用都要花费很多的时间和精力。因此用户需要花费大量的精力和时间在服务器这一计算资源的计划、管理和维护上。 在Severless架构下，当用户完成应用开发以后，软件将被不是在指定的运行环境，这个运行环境不再是具体的一台或多台服务器，而是支持Severless的云计算平台。当客户端请求到达或者指定事件发生时，云计算平台负责将应用部署到某台Severless云计算平台的主机中，Severless云计算平台保证该主机提供应用正常运行所需要的计算资源。当访问量升高时，云计算平台动态的增加应用的部署实例，点那个应用空闲一段时间后，云计算平台自动将应用从主机中卸载，回收计算资源。在这个过程中，用户无需关心具体需要几台服务器，同时原本花费在计划、管理和维护具体服务器上的时间和精力，也在Severless云计算平台的帮助下省去了。 用户无需关注服务器是因为底层的云计算平台完成了大量的自动化工作，因此Severless的实现和软件应用所在的Severless云计算平台有着很大的关系，这个云计算平台可以是公有云，如Amazon Web Services，Microsoft Azure，阿里云或者腾讯云，也可以是私有云，如通过OpenStack、Kubernetes结合一些Severless框架实现。 二、Severless带来的价值一项技术被广泛认可和采纳的原因往往不是因为这项技术有多新鲜或多酷，最重要的推动力是其能为业务带来巨大的商业和经济价值。 降低运营复杂度Severless架构使得软件应用和服务器实现了解耦，服务器不再是用户开发和运营应用的焦点。应用上线前，用户无需提前规划服务器的数量和规格。运维过程中，用户无需再持续监控和维护服务器的状态。用户的关注点可以更多的放在软件应用和体验和改进等其他能带来更多高业务价值的地方。 降低运营成本Severless的应用是按需执行的，应用只在请求需要处理或者事件触发时才会被加载运行，空闲状态下的应用本身是不占用计算资源的。如在公有云服务中，Severless只有处于在线状态下才进行计费，空闲状态下是不进行收费的。 以下是腾讯云SCF的计费方式云函数 SCF 按照实际使用付费，采用后付费小时结，以元为单位进行结算。SCF 账单由以下三部分组成，每部分根据自身统计结果和计算方式进行费用计算，结果以元为单位，并保留小数点后两位。 资源使用费用：资源使用费用 =（资源使用量 - 免费资源额度）× 资源使用单价资源使用量 = 函数配置内存 × 运行时长 调用次数费用：调用次数费用 = （函数调用量 - 免费调用额度） × 调用次数单价 外网出流量费用外网出流量费用 = 外网出流量 × 流量单价 缩短上线的时间在Severless架构下，应用的功能被解构成颗粒度的无状态函数，功能和功能之间的边界变得更加清晰，模块和模块之间的耦合度大大减少。因此，软件开发的效率会更高，迭代的周期更短，所依赖的服务（数据库、缓存、存储等）可直接通过云计算平台获取，应用的部署复杂度也会降低。（理论上，链路的trace追踪可能会更加复杂） 增强创新能力应用开发和部署效率的提升，同时计费方式的不同，用户可以以更快的速度和更低的成本尝试新的想法和创意。 三、Severless技术实现理念与实现 需要明确的一点是，Severless是一种软件架构的思想，而不是简单的工具和框架。因此不同的Severless服务和框架，他们的实现都不尽相同。下面是比较有名的Severless实现平台、工具、框架。 AWS Lambda 最早被大众认可的Severless实现 Azure Function 微软公有云的Severless实现 SCF 腾讯云的Severless实现 Open Whisk Apache社区开源的Severless框架 Kubeless 基于Kubernetes架构实现的开源Severless框架 Fission Platform9 推出的开源Severless框架 OpenFaaS 以容器技术为核心的开源Severless框架 Fn 来自Oracle的开源Severless框架 FaaS和BaaS 目前业界的各类Severless实现按功能而言，主要为应用服务提供了两个方面的支持：函数即服务（FaaS）以及后台即服务（BaaS）。 FaaSFaaS提供一个计算平台，在这个平台上，应用以一个或多个函数的形式开发、运行和管理。FaaS平台提供函数式应用的运行环境。FaaS可以根据实际的访问量进行应用的自动化动态加载和资源的动态分配。大多数的FaaS平台基于事件驱动的思想，可以根据预定义的事件触发指定的函数应用逻辑。 FaaS是目前Severless架构实现的一个重要的手段。FaaS平台的特带你在很大程度上影响了目前Severless应用的架构和实现方式。因此，有一部分人认为FaaS等同余Severless。随着技术的发展，目前主流观点是Severless和FaaS并不是等同的关系，而是包含和被包含的关系，仅仅通过FaaS平台并不能完全实现Severless架构的落地。因为当代的应用都不是孤立存在、独立运行的，一个完整的应用系统往往依赖于一些第三方的服务，比如数据库、分布式缓存以及消息队列等，如果这些服务也需要使用传统的方式去运维，代表用户还是需要耗费时间和精力对这些服务所需要的服务器资源进行管理，对于整个系统而言，并没有完全实现Severless化。 BaaS为了实现应用后台服务的Severless化，BaaS（服务即后台）也应该被纳入一个完整的Severless实现的范畴内。通过BasS平台将应用所依赖的第三方服务，如数据库、消息队列及存储等服务化并发布出来，用户通过向BasS平台申请所需要的服务进行消费，而不是关心这些服务的具体运维。BaaS涵盖的范围很广，包含任何应用所依赖的服务。比如数据库即服务（DBaaS）,传统情况下，数据库都是运行在数据中心的，由用户运维团队负责运，在DBaaS的场景下，用户想DBaaS平台申请数据库资源，而不用关心数据库的安装部署及运维。DBaaS只是一个例子，通过BaaS平台，应用将其所使用的任何第三方后台服务都进行Severless化，使得用户可以不再关心所依赖的服务底层计算资源运维，极大的减少了应用运维工作量和成本。 Severless的技术特点 按需加载应用的加载（load）和卸载（unload）都由Severless云计算平台控制，也就是说应用不一定是一直在线的，只有当请求或者事件到达时，才会被部署和启动激活，而当应用空闲一段时间时，应用会被自动停止和卸载。因此应用不会一直在线占用计算资源。 事件驱动应用的加载和执行由事件进行驱动，当产生如HTTP请求到达，消息队列接受到新的消息或者存储服务中的文件被修改了等事件时，将不同的事件被特定的函数进行关联，实现对不同事件的不同翻页动作。 状态非本地持久化由于应用不再与特定服务器进行关联，因此应用的状态不能保存在其运行的服务器上，无法做到传统意义上的状态本地持久化。 非会话保持由于应用不再与特定服务器进行关联，每次请求都可能是在新服务器上的应用实例。因此，用户无法保证同一客户端的两次请求是由同一个服务器的同一个实例处理，无法做到传统意义上的会话保持。 自动弹性伸缩Severless应用可以支持高并发，面对突发的高访问量，应用实例数量根据实际访问量由云平台进行弹性的自动拓展或收缩。（备注：需要注意要做防御，不然面对一些网络攻击，可能一夜之间资费就暴涨了很多）。 应用函数化应用被分解为细颗粒度的函数进行部署，同时状态又无法本地持久化，这些函数的操作可以说都是无状态的，类似于无状态函数。 依赖服务化依赖的外部服务如数据库等显然是有状态的，因此这类外部依赖需要进行服务化和无服务器化，即BaaS。 Severless的局限 控制力Severless突优点是无需关注底层计算资源，但面对需要掌控底层计算资源的应用场景时，Severless架构并不适合。 可移植性因为各个Severless云平台和框架具体实现并不尽相同，而且各个厂家的BaaS服务差别也很大，而行业间此时也没有产生一个标准，应用想要进行Severless化，就不得不和云平台厂商进行绑定，无法轻易移植到其他的云平台上。 安全性由于不同用户的应用或同一用户的不同应用可能共用底层的主机资源，因此对安全性较高的应用，存在潜在的安全风险。 性能由Severless应用实例长时间不使用，处在空闲状态下时，会被平台进行卸载，当请求或者事件再次来临时，平台需要重新加载应用实例，首次的加载以及重新加载都会产生一定的延时，因此对于延时敏感的应用，需要通过预先加载，或者延长空闲超时时间，或者保留最低处于加载状态下的实例等手段，进行处理。 执行时长目前大部分的Severless平台的FaaS函数的执行时长都存在限制，因此Severless更适合一些执行时长较短的任务。 技术成熟度Severless还是一门新兴的技术，文档和资料比较少。 四、Severless相关技术Severless与云计算 与Severless类似，PaaS用户可以将大部分精力放在应用的开发上。PaaS平台负责提供应用运行所需要的底层资源。如果一个PaaS实现了应用的自动弹性扩展，并且其启动速度足够快，执行时间足够短，基本可以把这个PaaS平台视作为一个Severless平台。纵观目前主流的PaaS平台和Severless平台，主要的差异点在于： 管理的颗粒度不同，PaaS以应用为单位，Severless以函数为单位 部署模式不同，PaaS将应用部署在主体、虚拟机或者容器中，而Severless是按需部署 作业类型不同，PaaS支持的应用类型更广，Severless只是偏重于执行时间跨度较短的任务 实例，PaaS平台一般需要设置每个实例需要的CPU和内存大小和实例的数量，而Severless则没有这个概念 Severless与微服务 Severless和微服务都强调功能的解构，两者的最小成员单位都是专注于做好一件事情，他们的目的是一致的，那就是提高应用开发和上线的效率。微服务强调化整为零，增加应用系统架构的灵活度。Severless强调将服务器移出用户的管理职责范围，从而降低管理的复杂度和成本。 微服务架构下，系统化整为零，架构上带来灵活的同时，也增加了开发、部署和运维的复杂度，对比而言，Severless的开发和运维成本更低一些。 FaaS架构 函数定义：一个函数实现的业务逻辑 函数实例：在运行状态的应用函数的实例 控制器：负责应用函数的加载、执行等流程的管理 事件：事件驱动架构中的事件 事件源：事件驱动架构中的事件来源。可以是一个数据库中插入的新的记录、目录中删除了一个文件、消息队列收到了新的消息等 触发规则：定义事件与函数之间的关联关系及触发的规则 平台服务：支撑应用运行的各类底层服务，如计算资源，数据存储等。 函数工作流 当用户发现有的场景需要多个函数共同写协作才能完成时，当涉及到多个函数执行时，就需要逻辑处理执行的顺序、错误重试、异常捕获以及状态传递等细节。一些FaaS实现开始提供真多FaaS函数的流程编排工具或服务，以简化FaaS应用的流程安排。","link":"/2020/04/04/Severless初探/"},{"title":"Vue 运行流程","text":"本文通过梳理Vue源码，分析Vue的运行流程，代码环境为web/runtime-with-compiler 第一步 设置core Vue首先声明Vue的构造函数，及其原型方法，主要为initMixin、stateMixin、eventsMixin、lifecycleMixin和renderMixin。function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue initMixininitMixin 主要是给设置_init原型函数。从代码中可以看出，_init主要是做合并配置项，根据配置项一步步初始化数据，并回调生命周期的钩子。其中initLifecycle、initEvents、initRender在init生命周期执行，initInjections, initState, initProvide在create生命周期执行。最后就是vm.$mount进入mount生命周期。 function initMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._init = function (options?: Object) { const vm: Component = this if (options &amp;&amp; options._isComponent) { initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') if (vm.$options.el) { vm.$mount(vm.$options.el) } }} stateMixinstateMixin主要是做了对Vue实例上源数据对象(data 和 props)代理，以禁止直接对数据进行修改，同时设置$set, delete, $watch等对数据进行修改的原型函数。 function stateMixin (Vue: Class&lt;Component&gt;) { // flow somehow has problems with directly declared definition object // when using Object.defineProperty, so we have to procedurally build up // the object here. const dataDef = {} dataDef.get = function () { return this._data } const propsDef = {} propsDef.get = function () { return this._props } Object.defineProperty(Vue.prototype, '$data', dataDef) Object.defineProperty(Vue.prototype, '$props', propsDef) Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function () {...}} eventsMixineventsMixin 主要是设置$on、$once、$off、$emit原型函数。从代码也能看出，所有的事件都被放在实例上的_events对象中，而每个_events[event]皆是一个数组。 function eventsMixin (Vue: Class&lt;Component&gt;) { const hookRE = /^hook:/ Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component { const vm: Component = this if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { vm.$on(event[i], fn) } } else { (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) { vm._hasHookEvent = true } } return vm } Vue.prototype.$once = ... Vue.prototype.$off = ... Vue.prototype.$emit = ... lifecycleMixinlifecycleMixin主要设置了_update、$forceUpdate、$destroy原型函数，_update主要将新老Vnode使用diff算法进行比较，然后更新html，$forceUpdate为强制刷新该实例，$destroy为销毁该实例。 export function lifecycleMixin (Vue: Class&lt;Component&gt;) { Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } restoreActiveInstance() // update __vue__ reference if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } } Vue.prototype.$forceUpdate = function () { const vm: Component = this // 通知该vm上的所有watch，让他们执行update方法 if (vm._watcher) { vm._watcher.update() } } Vue.prototype.$destroy = function () {...}} renderMixinrenderMixin主要给Vue的原型上创建$nextTick和_render和跟渲染相关的函数，_render函数根据组件选项里的render函数生成新的VNode虚拟dom节点 export function renderMixin (Vue: Class&lt;Component&gt;) { // install runtime convenience helpers installRenderHelpers(Vue.prototype) Vue.prototype.$nextTick = function (fn: Function) {} Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options if (_parentVnode) { vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) } // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try { // There's no need to maintain a stack becaues all render fns are called // separately from one another. Nested component's render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) } catch (e) { vnode = vm._vnode } finally { currentRenderingInstance = null } // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) { vnode = vnode[0] } // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) { vnode = createEmptyVNode() } // set parent vnode.parent = _parentVnode return vnode }} 根据环境设置特殊的原型函数当对浏览器环境打包vue时，若运行环境不为浏览器，则__patch__函数为() =&gt; {}(不采取任何操作)设置浏览器环境下的$mount函数，挂载element元素(hydrating选项代表服务器渲染) Vue.prototype.__patch__ = inBrowser ? patch : noopVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component {...} 第二步 实例化 Vue当新实例化一个Vue类时，根据initMixin里设置的初始化函数 Vue 双向绑定原理：当对某个对象上的某个属性使用defineReactive或observe的时候，会新建一个Dep实例，当获取对象上这个属性的值时，该Dep和Watch进行绑定，当对这个值进行修改的时候，该Dep通知绑定它的Watch们更新。 合并配置项在Vue中，有两种Vue实例，一种是Vue组件(VueComponent)，一种是根Vue实例(Vue)，VueComponent挂载在根Vue实例上，根Vue实例再挂载到某Element元素上，例如下面代码中，App.vue是一个VueComponent，new Vue(...)是一个根Vue实例。 // VueComponentimport App from './App.vue'Vue.config.productionTip = false// 根Vue实例(Vue)new Vue({ render: h =&gt; h(App),}).$mount('#app') 在初始化的时候，两个的行为会有不相同，VueComponent需要绑定到父级节点上，且对于events的listeners和props等属性进行合并处理，而根Vue实例只需要合并初始化时传入的配置。 if (options &amp;&amp; options._isComponent) { // 对父节点的一些属性进行继承 initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) }} initLifecycle初始化生命周期initLifecycle主要创建基础的生命周期属性以及$parent、$root、$children、$refs、_watcher等属性。$parent为上级Vue实例，$root为根Vue实例，$childre为下级Vue实例，$refs为特别注册的实例或元素对象。_watcher为存放观察者的列表。 function initLifecycle (vm: Component) { const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) { while (parent.$options.abstract &amp;&amp; parent.$parent) { parent = parent.$parent } parent.$children.push(vm) } vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = {} vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false} initEvents 初始化事件初始化_events属性，且如果在上级组件中有给组件绑定监听事件，对监听事件进行处理，将监听的事件调用到实例上的$on方法，添加到_events属性中。 function initEvents (vm: Component) { vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) { updateComponentListeners(vm, listeners) }} initRender 初始化渲染的参数初始化vnode、$slots、$createElement等属性，同时对$attrs和$listeners创建Dep function initRender (vm: Component) { vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) const parentData = parentVnode &amp;&amp; parentVnode.data defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)} callHook(vm, ‘beforeCreate’)init阶段完成，并执行beforeCreate的钩子函数。 initInjections 初始化注入对于inject 注入的值创建响应式Dep并绑定到实例上，获取值方式为一层一层向上获取父组件的_provided，直到符合要求。 initState 初始化数据属性首先创建_watchers数组，用于存放该实例上的观察者，然后对props、methods、data、computed、watch进行初始化。 function initState (vm: Component) { vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) { initData(vm) } else { observe(vm._data = {}, true /* asRootData */) } if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) }} initProps 根据父组件传入的propsData获取当value，然后进行defineReactive initData 根据data属性获取到值，并对此对象进行observe注1: 对于根Vue而言，data可以为对象，而对于VueComponent来说，data只能是Function，因为根Vue只会被实例化一次，而VueComponent可能被实例话使用多次。注2: observe函数，若传入的值非对象或为VNode则不操作，否则创建一个Observe。Observe对数组类型数据，遍历每一项重新observe，Observe对于普通对象的每一项进行defineReactive。 initComputed 为computed中的每一项创建一个Watcher并放入实例上的_computedWatchers。Watcher创建的时候，构造函数自动会执行一次传入的get方法，在此期间，get方法中涉及到的任何参数都会触发其defineReactive时创建的Dep的订阅。因此Dep和此Watcher的绑定就成立了。 initWatch 为每一项执行createWatcher而创建一个新的Watcher，并且执行一次get方法，和computed一样绑定Dep和该Watcher之间的依赖。当该项数据发生set时，该Watcher则会执行update，即创建该Watcher时传入的回调函数。 initProvide对每一项进行取值并放入实例的_provided中 function initProvide (vm: Component) { const provide = vm.$options.provide if (provide) { vm._provided = typeof provide === 'function' ? provide.call(vm) : provide }} callHook(vm, ‘created’)create阶段完成，并执行created的钩子函数 第三步 挂载Vue 编译templateVue有多种打包模式，分为runtime和compile，runtime代表提供Vue的运行环境，compile代表编译环境。若我们所有模版代码都自己写成render函数或通过webpack的vue-loader转为render函数，且代码里不使用template，则compile可以被省略。 如果未传入render选项，则去检测template选项。若template为id选择器、node节点、或者template不存在而存在el，则对上述内容分别处理，得到template字符串，然后使用compileToFunctions函数将template转为render Function。 if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) } } else if (template.nodeType) { template = template.innerHTML } else { return this } } else if (el) { template = getOuterHTML(el) } if (template) { const { render, staticRenderFns } = compileToFunctions(template, { outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns } beforeMount接着正式执行挂载函数mountComponent，首先callHook(vm, 'beforeMount')，然后创建新的Watcher，该Watcher的get方法为updateComponent，用于更新组件，传入before函数为更新组件前的钩子函数。创建Watcher的时候，构造函数里会默认执行一次get函数，即传入的updateComponent，执行_render来获取VNode，接着执行_update来将Vnode 进行patch，再更新到el上面。 function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { vm.$el = el if (!vm.$options.render) { vm.$options.render = createEmptyVNode } callHook(vm, 'beforeMount') let updateComponent = () =&gt; { vm._update(vm._render(), hydrating) } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted &amp;&amp; !vm._isDestroyed) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm} _render 获取Vnode调用实例上的$createElement来生产Vnode，在此期间，模版里绑定的数据访问会触发defineReactive时的 get，此时，将上一步创建的更新视图Watcher与数据的Dep绑定订阅关系。即当数据改变时，Dep通知该Watcher执行run(updateComponent)。至此，所有的Watcher和Dep全部都以绑定订阅关系完毕。 vnode = render.call(vm._renderProxy, vm.$createElement) _update 更新视图调用patch进行更新视图。如果有preVnode，则对上一步获取的Vnode 和 preVnode 进行patch，更新视图。若不存在preVnode，则对el和Vnode进行patch，使用CreateElm递归创建dom元素","link":"/2019/03/15/Vue运行流程/"}],"tags":[{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"Web","slug":"Web","link":"/tags/Web/"}],"categories":[]}